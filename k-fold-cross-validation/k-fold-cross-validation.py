import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from sklearn.model_selection import StratifiedKFold
from sklearn.preprocessing import LabelEncoder
from sklearn.feature_selection import mutual_info_classif
from sklearn.model_selection import train_test_split
from sklearn.naive_bayes import BernoulliNB
from sklearn.metrics import accuracy_score, precision_score, recall_score, f1_score
from sklearn.metrics import confusion_matrix, mean_squared_error, roc_curve, auc
from sklearn.preprocessing import label_binarize


data = pd.read_csv("TUANDROMD.csv")
data = data.dropna()
x = data.iloc[:, 0:-1].values
y = data.iloc[:, -1].values


le = LabelEncoder()
y = le.fit_transform(y)


information_gain = mutual_info_classif(x, y)
information_gain_with_index = list(enumerate(information_gain))
sorted_information_gain = sorted(information_gain_with_index, key=lambda x: x[1], reverse=True)


selected_features = sorted_information_gain[:150]
selected_feature_indices = [index for index, _ in selected_features]
x_selected = x[:, selected_feature_indices]


x_train, x_test, y_train, y_test = train_test_split(x_selected, y, test_size=0.33, random_state=0)


k_folds = 4
skf = StratifiedKFold(n_splits=k_folds, shuffle=True, random_state=0)


accuracy_list = []
precision_list = []
recall_list = []
f1_list = []
tpr_list = []
fpr_list = []
conf_matrices = []
mse_list = []


for train_index, test_index in skf.split(x_selected, y):
    x_train_cv, x_test_cv = x_selected[train_index], x_selected[test_index]
    y_train_cv, y_test_cv = y[train_index], y[test_index]

    
    bnb = BernoulliNB()
    bnb.fit(x_train_cv, y_train_cv)

    
    y_pred_cv = bnb.predict(x_test_cv)

    
    accuracy_list.append(accuracy_score(y_test_cv, y_pred_cv))
    precision_list.append(precision_score(y_test_cv, y_pred_cv, average='weighted'))
    recall_list.append(recall_score(y_test_cv, y_pred_cv, average='weighted'))
    f1_list.append(f1_score(y_test_cv, y_pred_cv, average='weighted'))
    conf_matrices.append(confusion_matrix(y_test_cv, y_pred_cv))
    mse_list.append(mean_squared_error(y_test_cv, y_pred_cv))
    
    fpr, tpr, _ = roc_curve(label_binarize(y_test_cv, classes=np.unique(y_test_cv)),
                            label_binarize(y_pred_cv, classes=np.unique(y_test_cv)))
    roc_auc = auc(fpr, tpr)

    tpr_list.append(tpr)
    fpr_list.append(fpr)

    

avg_accuracy = np.mean(accuracy_list)
avg_precision = np.mean(precision_list)
avg_recall = np.mean(recall_list)
avg_f1 = np.mean(f1_list)
avg_mse = np.mean(mse_list)
avg_conf_matrix = np.mean(conf_matrices, axis=0)


print("------Bernoulli Naive Bayes with K-fold Cross-Validation---------------")
print(f"Average Test Accuracy: {avg_accuracy:.2f}")
print(f"Average Precision: {avg_precision:.2f}")
print(f"Average Recall: {avg_recall:.2f}")
print(f"Average F1-Score: {avg_f1:.2f}")
print(f"Average Mean Squared Error (MSE): {avg_mse:.2f}")
print("Average Confusion Matrix")
print(avg_conf_matrix)


plt.figure()
mean_fpr = np.linspace(0, 1, 100)
mean_tpr = 0

for i in range(k_folds):
    plt.plot(fpr_list[i], tpr_list[i], lw=2, label=f'ROC curve (Fold {i + 1})')
    mean_tpr += np.interp(mean_fpr, fpr_list[i], tpr_list[i])

mean_tpr /= k_folds

roc_auc = auc(mean_fpr, mean_tpr)

plt.plot(mean_fpr, mean_tpr, color='b', label=f'Mean ROC curve (AUC = {roc_auc:.2f})')
plt.plot([0, 1], [0, 1], color='navy', lw=2, linestyle='--')
plt.xlabel('False Positive Rate')
plt.ylabel('True Positive Rate')
plt.title('Average Receiver Operating Characteristic (ROC) Curve')
plt.legend(loc='lower right')
plt.show()